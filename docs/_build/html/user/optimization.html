<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Optimization and Analysis Tools &mdash; PyNuMAD 1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/my_style.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="One-way Coupling to GUI" href="gui_coupling.html" />
    <link rel="prev" title="Finite Element Analysis Operations" href="fea.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> PyNuMAD
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../index.html">Home</a></li>
<li class="toctree-l1"><a class="reference internal" href="../apidoc/pynumad.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../introduction/index.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">User’s Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l2"><a class="reference internal" href="operation_modes.html">Modes of Operation</a></li>
<li class="toctree-l2"><a class="reference internal" href="blade_definition.html">Blade Definition</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="running_numad.html">Running NuMAD</a></li>
<li class="toctree-l2"><a class="reference internal" href="aero_sim.html">Aeroelastic Simulation and the <code class="docutils literal notranslate"><span class="pre">runIEC</span></code> Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="fea.html">Finite Element Analysis Operations</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Optimization and Analysis Tools</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#guidelines-for-running-optimization">Guidelines for Running Optimization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#defining-the-objective-function">Defining the Objective Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-design-variables">Defining Design Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="#defining-constraints">Defining Constraints</a></li>
<li class="toctree-l4"><a class="reference internal" href="#choosing-an-optimization-algorithm">Choosing an Optimization Algorithm</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#recent-updates">Recent Updates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="gui_coupling.html">One-way Coupling to GUI</a></li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html">Troubleshooting</a></li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html#known-issues">Known Issues</a></li>
<li class="toctree-l2"><a class="reference internal" href="conclusion.html#references">References</a></li>
<li class="toctree-l2"><a class="reference internal" href="classDefs.html">Object Classes, Properties, and Methods</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../developer.html">Developing pynumad</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted.html">Getting Started</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PyNuMAD</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">User’s Guide</a></li>
      <li class="breadcrumb-item active">Optimization and Analysis Tools</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/user/optimization.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="optimization-and-analysis-tools">
<span id="optimization"></span><h1>Optimization and Analysis Tools<a class="headerlink" href="#optimization-and-analysis-tools" title="Permalink to this heading"></a></h1>
<p>The NuMAD package can be used to perform design optimization on a blade
structure. Through manipulation of the data defining the blade design
stored in the NuMAD blade object, a design can be tailored to best
satisfy a given objective, defined by a fitness or objective function. A
typical objective function may be the mass of the blade subject to
various constraints on aspects such as stress/failure, deflection,
buckling, fatigue or modal frequencies. This section contains some
general guidelines for setting up and running and optimization and
recent updates related to the process.</p>
<section id="guidelines-for-running-optimization">
<span id="runningoptimization"></span><h2>Guidelines for Running Optimization<a class="headerlink" href="#guidelines-for-running-optimization" title="Permalink to this heading"></a></h2>
<p>Optimization is simple in concept. In short it is the process of finding
the best possible state or performance of a system for what is invested
in it within allowable variable ranges and satisfying necessary
constraints. It is in no small way the essence of engineering and
design, but nothing could be more open-ended as there are virtually
limitless possibilities in how to define variables, objective functions
and constraints as well as what optimization algorithms settings and
parameters to use. A set of tools is offered for obtaining running
finite element, and other analysis to obtain the quantities needed to
evaluate the performance of a blade structure and set up an
optimization. Some general guidelines are given here to assist with the
process.</p>
<p>In addition, an example optimization script to demonstrate the application
of the following concepts is included in <code class="docutils literal notranslate"><span class="pre">examples/optimization/optimizationExample.m</span></code>.
For further details, see <a class="reference internal" href="#optimization"><span class="std std-ref">Optimization and Analysis Tools</span></a>.</p>
<p>A good approach to putting together a customized optimization is to begin
from these scripts and modify according to the specific needs at hand,
while being mindful of the concepts presented in Sections <a class="reference internal" href="#definingobjective"><span class="std std-ref">Defining the Objective Function</span></a>
through <a class="reference internal" href="#choosingopimizationalgor"><span class="std std-ref">Choosing an Optimization Algorithm</span></a>.</p>
<section id="defining-the-objective-function">
<span id="definingobjective"></span><h3>Defining the Objective Function<a class="headerlink" href="#defining-the-objective-function" title="Permalink to this heading"></a></h3>
<p>The first critical step in setting up an optimization is defining a
fitness, or objective function. This is a function that numerically
evaluates the favorability/suitability of a given design based on some
criteria. Any optimization process seeks to minimize or maximize its
objective function, and therefore it should represent whatever quantity
should be extremized to produce a favorable result. The objective
function must be defined as MATLAB function, which accepts a vector
representing the current values of the design variables, along with any
other inputs needed, calculates the value of the objective and returns
it as an output. For some optimization algorithms, the gradient of the
objective with respect to the design variables may be helpful to return
as well, though usually not strictly required. A common objective for
structural optimization would be mass, for example. If it is desired to
minimize the mass of a blade subject to some set of constraints, the
objective function should calculate the mass of the blade based on the
design variables and return it as the primary output. An example
objective function definition is given in <code class="docutils literal notranslate"><span class="pre">examples/optimization/objectiveExample.m</span></code>, demonstrating
the use of NuMAD’s finite element analysis tools described in <a class="reference internal" href="fea.html#feaops"><span class="std std-ref">Finite Element Analysis Operations</span></a>.</p>
</section>
<section id="defining-design-variables">
<span id="definingdesignvars"></span><h3>Defining Design Variables<a class="headerlink" href="#defining-design-variables" title="Permalink to this heading"></a></h3>
<p>The next step is to define the design variables, or the variables that
can be changed in order to optimize the objective, and within what
ranges they can be changed. In NuMAD the design variables can, in
general, be any aspect of the blade’s design, as defined in <a class="reference internal" href="blade_definition.html#bladedefandterms"><span class="std std-ref">Blade Definition</span></a>,
in the description of the blade object. Typically, the design variables
should be taken from the input vector in the objective function and
assigned to their appropriate fields in the blade object, which can then
be used to evaluate any necessary quantities for the objective. The upper and lower bounds for each design variable are
usually passed to the main optimization function, which takes charge of
enforcing these bounds, but they may also be passed to the objective
function if it is useful. Determining appropriate initial values, upper
bounds and lower bounds can be challenging, and care should be taken to
make sure that the bounds do not violate physical limits, such as making
the spar cap wider than the blade or setting negative values for
composite layer thicknesses.</p>
</section>
<section id="defining-constraints">
<span id="definingconstraints"></span><h3>Defining Constraints<a class="headerlink" href="#defining-constraints" title="Permalink to this heading"></a></h3>
<p>Next is to identify any constraints that must be imposed on the design.
A constraint is any condition that must be satisfied in order to make a
design feasible, or eligible as a solution. Constraints and objectives
are fundamentally similar, in that they are both essentially goals that
are hoped to be achieved in the final design. The primary difference is
that constraints typically impose a specific value, relative value or
range on a quantity which is not negotiable for a solution to be
acceptable. In contrast, an objective is a quantity that is sought to be
extremized, but the target value is not necessarily known, and it may be
compromised if necessary for the sake of constraints. There are
different types of constraints, and the best way to impose them can
depend on the type and the situation.</p>
<p>One type of constraint is a direct design variable constraint that
imposes a value or closed-form mathematical relationship between the
design variables themselves. The simplest example is the upper and lower
bounds placed to define the ranges of each variable. Usually these arise
from physical limitations and boundaries. For instance, if optimizing
the positions of two shear webs in a blade, the fore web must always be
positioned in front of the aft web, though bounds may still overlap.
This type of constraint be linear or nonlinear, and most optimizers can
easily accommodate them defined alongside of the objective function in
the form of a constraint matrix or similar structure, ensuring that they
are satisfied throughout the optimization.</p>
<p>Another type of constraint imposes a condition not on the design
variables themselves, but on some aspect of the performance of the
structure. An example of this is imposing that the maximum displacement
of the blade under an applied loading cannot exceed a certain limit.
Constraints like this are almost never linear or expressible in closed
form, and thus tend to be less straightforward to enforce.</p>
<p>One approach is to test the constraint at each design state throughout
the optimization, and simply discard any state that does not satisfy the
constraint, continuing to search in other directions of the design space
until a feasible state is found. This can be effective if the constraint
is not too restrictive, but it is potentially difficult, especially with
numerous complex constraints, to find states that fully satisfy all
constraints through blind trial-and-error. As a result, an optimizer can
run itself into the ground trying to find feasible candidates in this
manner.</p>
<p>An alternative method is to quantify the level of satisfaction of the
constraint in the form of a <em>penalty function</em>, and factor it in as part
of the total objective value. If the penalty function grows steadily
higher the further a constraint is violated, then the optimizer will
definitively favor solutions that satisfy the constraint and migrate
toward feasible solutions if it is violated. Returning to the former
example, if it is desired to ensure that the maximum displacement of a
structure under loading does not exceed a certain limit, a penalty
function could be derived in the form of, say, a power of the constraint
index as shown:</p>
<div class="math notranslate nohighlight">
\[U &lt; U_{\max} \Longrightarrow \frac{U}{U_{\max}} &lt; 1\]</div>
<div class="math notranslate nohighlight">
\[P = {c_{1}\left( \frac{U}{U_{\max}} \right)}^{c_{2}}\]</div>
<p>where <span class="math notranslate nohighlight">\(c_{1}\)</span> and <span class="math notranslate nohighlight">\(c_{2}\)</span> are some predetermined
coefficients. This method is generally effective, although it does not
guarantee that the final design perfectly satisfies the constraints, and
can require fine-tuning and adjustment of the constant parameters on the
part of the user. These are just some examples, and ultimately it is up
to the judgement of the user the most appropriate way to incorporate
their constraints in with the objective.</p>
</section>
<section id="choosing-an-optimization-algorithm">
<span id="choosingopimizationalgor"></span><h3>Choosing an Optimization Algorithm<a class="headerlink" href="#choosing-an-optimization-algorithm" title="Permalink to this heading"></a></h3>
<p>Numerous optimization algorithms exist, each with many options and
settings possible. A variety of functions are available built into
MATLAB, but many external packages are available as well. In choosing
the optimizer for a specific problem, it is helpful to classify
algorithms into two main types: gradient-based and gradient-free. These
two types have distinctly different strengths and weaknesses which are
important to understand in setting up a successful optimization.</p>
<p>Gradient-based optimizers work by beginning with the system and design
variables in a given initial state and taking a series of steps through
the design space searching for improved solutions. The search direction,
or the direction of the step by which the design variables are changed
each iteration is derived in some way from the gradient of the
objective, that is its derivatives with respect to the design variables.
The gradient is, by definition, the direction of most rapid
increase/decent for a function that is continuous and smooth throughout
the design space. The theory is that by using this direction, and
sometimes factoring in the Hessian of the objective and projecting out
the gradients of constraint equations, etc., it should be possible to
steadily reduce an objective from the initial state until it reaches a
minimum value.</p>
<p>Gradient-based optimizers are direct and efficient in suitable
applications. They typically require relatively few evaluations of the
objective function for an optimization, particularly if the
exact/analytical gradient is provided along with the objective. This
makes them attractive for problems with a large number of design
variables, or requiring high-fidelity analysis for evaluation of the
objective. They are, however, inherently local optimizers, meaning that
they seek out local extrema in the proximity of the initial state, which
may not be the most optimal solution in the whole design space. They
also require the objective function to be a continuous, smooth function
of the design variables which can be challenging to define in some
cases, while still representing the true objective that is sought after.
Examples of gradient-based optimizers include fmincon in the MATLAB
built-in optimization suite, or SNOPT, a widely-used sparse nonlinear
optimizer out of Stanford.</p>
<p>Gradient-free optimizers include a wide range of algorithms, which
search the design space in some way other than gradient-based. Because
of this, they do not rely on the objective having any particular
characteristics like continuity or smoothness, and they are in that
sense more robust and versatile than gradient-based alternatives. They
also tend to search the design space more thoroughly, although it should
be noted that it is rarely guaranteed that any optimization algorithm
will find the most optimal possible solution in the entire design space.
The methods that gradient-free optimizers use are diverse, but they
typically require a large number of objective function evaluations to
work effectively. If the objective is expensive to evaluate and the
number of design variables is very large, they can become prohibitively
costly, ineffective or both. In general, gradient-free methods are best
for problems with low to moderate fidelity in the objective simulations
and a few dozen design variables or less. Examples of gradient-free
optimizers include particle swarm and genetic algorithms (both offered
in the MATLAB suite), as well as some machine learning applications.</p>
<p>Keeping these basic guidelines in mind should assist in the process of
setting up an optimization for a specific application. In some
situations, it may be a prudent approach to first set up a gradient-free
optimization using lower fidelity analysis and a limited design space to
find a semi-optimal design, and proceed to fine tune it with a
higher-fidelity model and design space in a gradient-based optimizer.
Ultimately it is up to the user to determine the best course of action,
and the most important tool is your own judgement and ingenuity.</p>
</section>
</section>
<section id="recent-updates">
<span id="recentopiupdates"></span><h2>Recent Updates<a class="headerlink" href="#recent-updates" title="Permalink to this heading"></a></h2>
<p>Several updates have been made related to the tools for analysis and
optimization since the previous release of NuMAD. Among the most
significant is the addition of the finite-element-based analysis of
fatigue damage, and other module changes described in <a class="reference internal" href="fea.html#feaops"><span class="std std-ref">Finite Element Analysis Operations</span></a>. But in
addition to these, a few more subtle improvements have been made as will
be briefly described here.</p>
<p>For a period of time, when a finite element analysis of a blade was
performed based on the load output from a FAST/OpenFAST analysis, the
distributed load constructed and applied to the nodes of the model
consisted entirely of forces in the transverse (flap and edge)
directions, with no loading in the longitudinal direction. The reasoning
was that the flap and edge moments represented the most significant
loading on the blade for the purposes of predicting maximum stress, etc.
While this is generally true, it was decided that moving forward it
would be best to include the forces and moments in the longitudinal
direction to account for centrifugal effects and torsional moments for
the sake of completeness.</p>
<p>In the current version when forces are compiled from the FAST/OpenFAST
output in the functions: <code class="docutils literal notranslate"><span class="pre">source\utilities\designTools\fast\FastLoads4Ansys.m</span></code>
and <code class="docutils literal notranslate"><span class="pre">source\utilities\feLoads\getForceDistributionAtTime.m</span></code></p>
<p>the longitudinal forces and torsional moments are compiled and applied
to the blade model along with the flap and edge moments. The appropriate
modifications were also made to the function: <code class="docutils literal notranslate"><span class="pre">source\utilities\feLoads\beamForceToAnsysShell.m</span></code>
to accommodate the longitudinal forces in the process. On a related
note, the forces and moments from the output files are given in a local
coordinate system at each point along the blade, which rotates along
with the structural twist defined for that point. For accuracy, the
forces and moments are now transformed to the blade global coordinate
system before being applied to the model. There is a new function
available to process a given output file, perform the transformation and
return the data in global coordinates:
<code class="docutils literal notranslate"><span class="pre">source\utilities\designTools\fast\loadFASTOutDataGageRot.m</span></code></p>
<p>Finally, in some cases the user may want to define the blade model
by providing a <code class="docutils literal notranslate"><span class="pre">.yaml</span></code> file, and reading it into an instance of the
NuMAD blade object for processing or design iteration.  But in several
places throughout the process of <code class="docutils literal notranslate"><span class="pre">runIEC</span></code>, and the application of loads,
information such as pre-bend, pre-sweep and structural twist is taken from
the FAST/OpenFAST files in the model directory. To make sure the necessary
information in these files is consistent with that in the <code class="docutils literal notranslate"><span class="pre">.yaml</span></code> file,
a convenient function was built, named: <code class="docutils literal notranslate"><span class="pre">source\utilities\designTools\fast\updateFASTFromBladeDef.m</span></code>
which updates and rewrites the fast files using the current data in a
blade file. This can be called immediately after reading the <code class="docutils literal notranslate"><span class="pre">.yaml</span></code>
file, and before performing any analysis to ensure the consistency of
data.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="fea.html" class="btn btn-neutral float-left" title="Finite Element Analysis Operations" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="gui_coupling.html" class="btn btn-neutral float-right" title="One-way Coupling to GUI" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Kirk Bonney.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>